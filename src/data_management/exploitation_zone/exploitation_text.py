# text_embed_from_minio.py
import json, time, hashlib
from typing import List
from src.common.minio_client import get_minio_client
from src.common.chroma_client import get_client, get_text_collection

def _hash_text(t: str, n: int = 16) -> str:
    return hashlib.sha256(t.encode("utf-8")).hexdigest()[:n]

def _chunk(s: str, max_chars=800, overlap=100) -> List[str]:
    s = s.strip()
    if not s: return []
    step = max(1, max_chars - min(overlap, max_chars-1))
    return [s[i:i+max_chars] for i in range(0, len(s), step)]

def ingest_json_root_list_from_minio(
    json_key: str,
    root_key: str = "root",
    default_lang: str = "en",
    max_chars: int = 800,
    overlap: int = 100,
    batch_size: int = 512,
) -> int:
    """
    Lee un único objeto JSON en MinIO con forma:
      { "root": ["receta1", "receta2", ...] }
    Crea embeddings de cada receta (troceadas) y los guarda en Chroma.
    Metadatos: source_key, idx (posición), file_hash, split_id, lang, created_at.
    """
    s3 = get_minio_client()
    o = s3.get_object("trusted-zone", json_key)  # ajusta bucket si usas otro
    data = o.read().decode("utf-8", errors="ignore")
    o.close(); o.release_conn()

    payload = json.loads(data)
    if root_key not in payload or not isinstance(payload[root_key], list):
        raise ValueError(f"JSON {json_key} debe contener lista en '{root_key}'")

    items: List[str] = [str(x) for x in payload[root_key]]

    cli = get_client()
    col = get_text_collection(cli)

    ids, docs, metas = [], [], []
    total = 0
    now = int(time.time())

    for idx, text in enumerate(items):
        base = _hash_text(f"{json_key}::{idx}::{text[:200]}")
        for split_id, chunk in enumerate(_chunk(text, max_chars, overlap)):
            ids.append(f"{base}-{split_id}")
            docs.append(chunk)
            metas.append({
                "source_key": json_key,
                "idx": idx,
                "file_hash": base,
                "split_id": split_id,
                "created_at": now,
                "lang": default_lang
            })

        if len(ids) >= batch_size:
            col.add(ids=ids, documents=docs, metadatas=metas)
            total += len(ids); ids.clear(); docs.clear(); metas.clear()

    if ids:
        col.add(ids=ids, documents=docs, metadatas=metas)
        total += len(ids)

    print(f"OK - Textos ingeridos desde {json_key}: {total}")
    return total

if __name__ == "__main__":
    # ejemplo de uso
    ingest_json_root_list_from_minio(
        json_key="trusted/text_data/recipes.json",  # ruta real en MinIO
        root_key="root",
        default_lang="en",
        max_chars=800,
        overlap=100,
    )
