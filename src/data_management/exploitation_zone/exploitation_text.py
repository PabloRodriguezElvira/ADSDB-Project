import json, time, hashlib
from typing import List, Optional
from src.common.progress_bar import ProgressBar

from src.common.minio_client import get_minio_client
from src.common.chroma_client import get_client, get_text_collection
import src.common.global_variables as config


def _hash_text(t: str, n: int = 16) -> str:
    """Return a short SHA-256 hash for the given text."""
    return hashlib.sha256(t.encode("utf-8")).hexdigest()[:n]


def _chunk(s: str, max_chars: Optional[int] = 800, overlap: int = 100) -> List[str]:
    """
    Split long text into overlapping chunks of up to `max_chars` characters.

    Overlap ensures continuity between segments for better text embeddings.
    If `max_chars` is None or <= 0, the text is returned as a single chunk.
    """
    s = s.strip()
    if not s:
        return []
    if not max_chars or max_chars <= 0:
        return [s]

    step = max(1, max_chars - min(overlap, max_chars - 1))
    return [s[i:i + max_chars] for i in range(0, len(s), step)]


def ingest_json_root_list_from_minio(
    json_key: str,
    root_key: str = "root",
    default_lang: str = "en",
    max_chars: int = 800,
    overlap: int = 100,
    batch_size: int = 512,
) -> int:
    """
    Ingest text data from a JSON file in MinIO into a Chroma collection.

    Steps:
      1. Download JSON from the trusted bucket.
      2. Extract list elements.
      3. Limit to the first N entries.
      4. Split each text into chunks.
      5. Upload chunks with metadata into Chroma.
    """
    # Download JSON file from MinIO 
    s3 = get_minio_client()
    o = s3.get_object("trusted-zone", json_key)
    data = o.read().decode("utf-8", errors="ignore")
    o.close()
    o.release_conn()

    # Parse JSON content 
    payload = json.loads(data)
    if root_key not in payload or not isinstance(payload[root_key], list):
        raise ValueError(f"JSON {json_key} must contain list in '{root_key}'")

    items: List[str] = [str(x) for x in payload[root_key]]

    # Limit on the number of entries to process 
    MAX_TO_PROCESS = None
    print(f"[INFO] Limiting ingestion to the first {MAX_TO_PROCESS} items.")
    items = items[:MAX_TO_PROCESS]

    # Initialize Chroma client and collection 
    cli = get_client()
    col = get_text_collection(cli)

    ids, docs, metas = [], [], []
    total = 0
    now = int(time.time())
    N = len(items)
    if N == 0:
        print(f"[WARN] No texts found in {json_key}.")
        return 0

    print(f"Processing {N} texts from {json_key}...\n")

    # Iterate over all text entries and ingest 
    with ProgressBar(
        total=N,
        description="Ingesting texts",
        unit="txt",
        unit_scale=False,
    ) as progress:
        for idx, text in enumerate(items):
            progress.set_description(f"Ingesting text {idx + 1}/{N}", refresh=False)
            base = _hash_text(f"{json_key}::{idx}::{text[:200]}")  # Unique ID prefix for each text

            # Split long text into chunks
            for split_id, chunk in enumerate(_chunk(text, max_chars, overlap)):
                ids.append(f"{base}-{split_id}")
                docs.append(chunk)
                metas.append({
                    "source_key": json_key,
                    "idx": idx,
                    "file_hash": base,
                    "split_id": split_id,
                    "created_at": now,
                    "lang": default_lang
                })

            # Batch insert into Chroma
            if len(ids) >= batch_size:
                col.add(ids=ids, documents=docs, metadatas=metas)
                total += len(ids)
                ids.clear()
                docs.clear()
                metas.clear()

            progress.update(1)

    # Final flush for remaining data 
    if ids:
        col.add(ids=ids, documents=docs, metadatas=metas)
        total += len(ids)

    print(f"\nOK - Texts ingested from {json_key}: {total}")
    return total


if __name__ == "__main__":
    # Run ingestion using the configured trusted text path and default parameters
    ingest_json_root_list_from_minio(
        json_key=f"{config.TRUSTED_TEXT_PATH}{config.JSON_NAME}",
        root_key="root",
        default_lang="en",
        max_chars=None,
        overlap=0,
    )
