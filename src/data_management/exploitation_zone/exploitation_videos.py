import io
import hashlib
import time
import tempfile
from typing import List
import numpy as np
import cv2
from tqdm import tqdm

from minio.error import S3Error
from src.common.minio_client import get_minio_client
from src.common.chroma_client import get_client, get_image_collection

TRUSTED_BUCKET = "trusted-zone"
SRC_PREFIX = "trusted/video_data/"   # ajusta si tu prefijo es otro

def _hash_text(s: str, n: int = 16) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()[:n]

def list_objects(client, bucket, prefix) -> List:
    return [
        obj for obj in client.list_objects(bucket, prefix=prefix, recursive=True)
        if not obj.object_name.endswith("/")
    ]

def extract_frames_from_file(path: str, frame_interval_s: float = 1.0, max_frames: int = 100):
    """
    Generator que devuelve (frame_idx, timestamp_s, frame_bgr) para un fichero de vídeo.
    Extrae 1 frame cada `frame_interval_s` segundos hasta max_frames.
    """
    cap = cv2.VideoCapture(path)
    if not cap.isOpened():
        return

    fps = cap.get(cv2.CAP_PROP_FPS) or 25.0
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT) or 0)
    duration_s = total_frames / fps if fps > 0 else 0

    step_frames = max(1, int(round(frame_interval_s * fps)))
    frame_idx = 0
    yielded = 0

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        if frame_idx % step_frames == 0:
            timestamp_s = frame_idx / fps if fps > 0 else 0.0
            yield yielded, timestamp_s, frame  # BGR
            yielded += 1
            if yielded >= max_frames:
                break
        frame_idx += 1

    cap.release()

def ingest_trusted_videos(
    frame_interval_s: float = 1.0,
    max_frames_per_video: int = 50,
    batch_size: int = 64,
):
    s3 = get_minio_client()
    cli = get_client()
    col = get_image_collection(cli)   # usa la colección de imágenes; cambia si quieres otra
    objects = list_objects(s3, TRUSTED_BUCKET, SRC_PREFIX)
    print(f"Procesando {len(objects)} vídeos desde {SRC_PREFIX}...")

    ids, imgs_np, metas = [], [], []
    total = 0
    now = int(time.time())

    for obj in tqdm(objects, desc="Ingestando vídeos", unit="video"):
        try:
            s3obj = s3.get_object(TRUSTED_BUCKET, obj.object_name)
            # Escribimos streaming a fichero temporal (evita cargar todo en memoria)
            with tempfile.NamedTemporaryFile(suffix=".mp4", delete=True) as tmp:
                for chunk in s3obj.stream(32 * 1024):
                    tmp.write(chunk)
                tmp.flush()
                s3obj.close()
                s3obj.release_conn()

                # Extraer frames
                for frame_idx, timestamp_s, frame_bgr in extract_frames_from_file(
                    tmp.name, frame_interval_s=frame_interval_s, max_frames=max_frames_per_video
                ):
                    # Convertir BGR -> RGB
                    frame_rgb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
                    arr = np.asarray(frame_rgb, dtype=np.uint8)

                    fid = _hash_text(f"{obj.object_name}::{frame_idx}::{int(timestamp_s*1000)}")
                    ids.append(fid)
                    imgs_np.append(arr)
                    metas.append({
                        "video_key": obj.object_name,
                        "frame_idx": frame_idx,
                        "timestamp_s": float(timestamp_s),
                        "file_hash": fid,
                        "size_bytes": tmp.tell(),
                        "created_at": now,
                    })

                    # flush por lotes
                    if len(ids) >= batch_size:
                        col.add(ids=ids, images=imgs_np, metadatas=metas)
                        total += len(ids)
                        ids.clear(); imgs_np.clear(); metas.clear()

        except S3Error as e:
            tqdm.write(f"⚠️ SKIP (MinIO): {obj.object_name} ({e})")
            continue
        except Exception as e:
            tqdm.write(f"⚠️ ERROR procesando {obj.object_name}: {e}")
            continue

    # resto final
    if ids:
        col.add(ids=ids, images=imgs_np, metadatas=metas)
        total += len(ids)

    print(f"\nOK - Frames ingeridos en Chroma: {total}")
    return total

if __name__ == "__main__":
    ingest_trusted_videos(
        frame_interval_s=1.0,     # 1 frame por segundo (ajusta)
        max_frames_per_video=60,  # máximo por vídeo
        batch_size=128,
    )
