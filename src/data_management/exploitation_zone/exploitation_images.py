import io, hashlib, time, os
import numpy as np
from PIL import Image, UnidentifiedImageError
from minio.error import S3Error

from src.common.minio_client import get_minio_client
from src.common.chroma_client import get_client, get_image_collection
import src.common.global_variables as config
from src.common.progress_bar import ProgressBar


def _hash_bytes(b: bytes, n: int = 16) -> str:
    """Return a short SHA-256 hash for given bytes."""
    return hashlib.sha256(b).hexdigest()[:n]


def list_objects(client, bucket, prefix):
    """List all files from a MinIO bucket and prefix."""
    return [
        obj for obj in client.list_objects(bucket, prefix=prefix, recursive=True)
        if not obj.object_name.endswith("/")
    ]


def ingest_trusted_images(batch_size: int = 128) -> int:
    """
    Ingest trusted images from MinIO into the Chroma image collection.

    Steps:
      1. Download images from the trusted bucket.
      2. Convert each image into a NumPy array.
      3. Compute a short hash as unique ID.
      4. Insert embeddings and metadata into Chroma in batches.
    """
    # Initialize MinIO and Chroma clients
    client_s3 = get_minio_client()
    ch_client = get_client()
    col = get_image_collection(ch_client)

    # List all images under the trusted image path
    objects = list_objects(client_s3, config.TRUSTED_BUCKET, config.TRUSTED_IMAGE_PATH)
    total_objects = len(objects)
    if total_objects == 0:
        print("[WARN] No trusted images found for exploitation ingestion.")
        return 0

    print(f"Processing {total_objects} images from MinIO...\n")

    # Containers for image data and metadata
    ids, imgs_np, metas = [], [], []
    total = 0
    now = int(time.time())

    # Progress bar for tracking ingestion
    with ProgressBar(
        total=total_objects,
        description="Embedding images",
        unit="img",
        unit_scale=False,
    ) as progress:
        for obj in objects:
            progress.set_description(f"Embedding {os.path.basename(obj.object_name)}", refresh=False)
            
            # Download image from MinIO
            try:
                s3obj = client_s3.get_object(config.TRUSTED_BUCKET, obj.object_name)
                data = s3obj.read()
                s3obj.close()
                s3obj.release_conn()
            except S3Error as e:
                progress.write(f"SKIP (MinIO): {obj.object_name} ({e})")
                progress.update(1)
                continue

            # Load image using PIL and convert to NumPy array
            try:
                im = Image.open(io.BytesIO(data)).convert("RGB")
                arr = np.asarray(im, dtype=np.uint8)
            except (UnidentifiedImageError, OSError) as e:
                progress.write(f"SKIP (PIL): {obj.object_name} ({e})")
                progress.update(1)
                continue

            # Compute unique hash and store metadata
            fid = _hash_bytes(data)
            ids.append(fid)
            imgs_np.append(arr)
            metas.append({
                "source_key": obj.object_name,
                "file_hash": fid,
                "size": len(data),
                "created_at": now,
            })

            # Batch insert into Chroma 
            if len(ids) >= batch_size:
                col.add(ids=ids, images=imgs_np, metadatas=metas)
                total += len(ids)
                ids.clear()
                imgs_np.clear()
                metas.clear()

            progress.update(1)

        # Final flush for remaining images
        if ids:
            col.add(ids=ids, images=imgs_np, metadatas=metas)
            total += len(ids)

    print(f"\nOK - Image embeddings ingested into Chroma: {total}")
    return total


if __name__ == "__main__":
    ingest_trusted_images()
