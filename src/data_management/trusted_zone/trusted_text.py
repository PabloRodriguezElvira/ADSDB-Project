# -*- coding: utf-8 -*-
"""trusted_text.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jusf3GziV2cFPmPmZgjgmm1nIOsNvR0y
"""

import os
import io
import json
import re
from datetime import datetime
from zoneinfo import ZoneInfo
from src.common.minio_client import get_minio_client
from minio import Minio
from minio.error import S3Error



# Buckets
FORMATTED_BUCKET = "formatted-zone"
TRUSTED_BUCKET = "trusted-zone"

# Folders
SRC_PREFIX = "formatted/text_data/"
DST_PREFIX = "trusted/text_data/"

FIELDS_TO_KEEP = ["title", "ingredients", "directions"]

def list_objects(client, bucket, prefix):
    for obj in client.list_objects(bucket, prefix=prefix, recursive=True):
        if not obj.object_name.endswith("/"):
            yield obj.object_name


def dst_key_for(src_key: str) -> str:
    if src_key.startswith(SRC_PREFIX):
        dst_key = src_key.replace(SRC_PREFIX, DST_PREFIX, 1)
    else:
        dst_key = DST_PREFIX + os.path.basename(src_key)
    base, _ = os.path.splitext(dst_key)
    return base + ".json"

#functions to clean
#remove when we hacve more than one white spaces
def remove_whitespace(text: str) -> str:
    if isinstance(text, str):
      text = text.replace('\u200b', '')   # zero-width space
      text = text.replace('\ufeff', '')   # BOM mark (invisible al inicio)
      text = re.sub(r'\s+', ' ', text)    # substitutes whatever seq of 1 or more spaces by " "
      return text.strip() # removes the first and last space
    else:
      return text

#function to anonymize
def anonymize_text(text: str, mask_names: bool = False) -> str:
    if isinstance(text, str):
      text = re.sub(r'\b[\w\.-]+@[\w\.-]+\.\w+\b', '[EMAIL]', text)
      text = re.sub(r'(https?://\S+|www\.\S+)', '[URL]', text)
      text = re.sub(r'@\w+', '[USER]', text)
      text = re.sub(r'\+?\d[\d\s\-]{7,}\d', '[PHONE]', text)
      if mask_names:#to anonymize names
          text = re.sub(r'\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+\b', '[NAME]', text)
      return text
    else:
      return text

#lower words but preserving the tags
def to_lower_preserving_tags(text: str) -> str:
    if isinstance(text, str):
      pattern = re.compile(r'\[([A-Z]+)\]')
      lowered = text.lower()
      return pattern.sub(lambda m: f'[{m.group(1)}]', lowered)
    else:
      return text

# combining the three functiona
def clean_text(text: str) -> str:
    text = remove_whitespace(text)
    text = anonymize_text(text, mask_names=True)
    text = to_lower_preserving_tags(text)
    return text

def process_text(client, key: str):
    print("Processing:", key)

    obj = client.get_object(FORMATTED_BUCKET, key)
    raw = obj.read()
    obj.close(); obj.release_conn()

    text = raw.decode("utf-8")
    data = json.loads(text)
    entries = data.get("root", [])

    cleaned_entries = []

    for e in entries:
        cleaned_entry = {}
        for field in FIELDS_TO_KEEP:
            if field not in e:
                continue

            value = e[field]

            # apply the clean_text function to str
            if isinstance(value, list):
                cleaned_entry[field] = [clean_text(x) for x in value]
            elif isinstance(value, str):
                cleaned_entry[field] = clean_text(value)
        cleaned_entries.append(cleaned_entry)

    output = {
        "schema_version": 1,
        "root": cleaned_entries
    }

    payload = json.dumps(output, ensure_ascii=False, indent=2, sort_keys=True).encode("utf-8")
    dst_key = dst_key_for(key)

    metadata = {
        "x-amz-meta-source-key": key,
        "x-amz-meta-processed-at": datetime.now(ZoneInfo("Europe/Madrid")).isoformat(),
        "x-amz-meta-schema-version": "1",
    }

    client.put_object(
        TRUSTED_BUCKET,
        dst_key,
        io.BytesIO(payload),
        length=len(payload),
        content_type="application/json",
        metadata=metadata
    )

    print(f" Saved cleaned file in: {TRUSTED_BUCKET}/{dst_key}")

def main():
    client = get_minio_client()

    for key in list_objects(client, FORMATTED_BUCKET, SRC_PREFIX):
        try:
            process_text(client, key)
        except S3Error as e:
            print(f"MinIO error with {key}: {e}")
        except Exception as e:
            print(f"Error processing {key}: {e}")

if __name__ == "__main__":
    main()