# -*- coding: utf-8 -*-
"""trusted_images.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RZeOxjr36ZFVg1-PvTGj0PTmtknlimg2
"""

import os
import io
import re
import argparse
from datetime import datetime
from zoneinfo import ZoneInfo
from src.common.minio_client import get_minio_client
from minio.error import S3Error
from PIL import Image, ImageStat, UnidentifiedImageError
import cv2
import numpy as np
import hashlib
from collections import defaultdict
import warnings
warnings.filterwarnings("ignore", category=UserWarning)

# Buckets
FORMATTED_BUCKET = "formatted-zone"
TRUSTED_BUCKET = "trusted-zone"
REJECTED_BUCKET = "rejected-zone"
# Folders
SRC_PREFIX = "formatted/image_data/"
DST1_PREFIX = "trusted/image_data/"
DST2_PREFIX = "rejected/image_data/"

def list_objects(client, bucket, prefix):
    for obj in client.list_objects(bucket, prefix=prefix, recursive=True):
        if not obj.object_name.endswith("/"):
            yield obj.object_name

def dst_key_for(src_key: str, dst_prefix: str) -> str:
    if src_key.startswith(SRC_PREFIX):
        dst_key = src_key.replace(SRC_PREFIX, dst_prefix, 1)
    else:
        dst_key = os.path.join(dst_prefix, os.path.basename(src_key))
    return dst_key

#checking out if we are able to open all the images, the size, png, corr
def is_image_valid(data: bytes) -> bool:
    try:
        img = Image.open(io.BytesIO(data))
        img.verify()
        return True
    except (UnidentifiedImageError, OSError):
        return False

def image_properties(data: bytes, expected_size=(512, 512)) -> dict:
    result = {

        "format": None,
        "size": None,
        "color": None,
        "size_ok": False,
        "color_ok": False,
        "format_ok": False,
        "error": None
    }

    try:
        with Image.open(io.BytesIO(data)) as img:
            img.load()

            result["format"] = img.format
            result["size"] = img.size
            result["color"] = img.mode

            if img.size == expected_size:
                result["size_ok"] = True

            if img.mode in ("RGB", "RGBA"):
                result["color_ok"] = True

            if img.format == "PNG":
                result["format_ok"] = True

    except Exception as e:
        result["error"] = str(e)

    return result

# Image properties such as brightness
def brightness_and_contrast(data: bytes) -> dict:
    img = Image.open(io.BytesIO(data)).convert("L")  # grey's scale
    stat = ImageStat.Stat(img)
    brightness = stat.mean[0] / 255.0  # brightness normalized
    contrast= stat.stddev[0] / 255.0  # contrast normalized

    return {
        "brightness": round(brightness, 3),
        "contrast": round(contrast, 3),
        "brightness_ok": 0.3 <= brightness <= 0.7,
        "contrast_ok": contrast >= 0.2
    }

def sharpness(data: bytes) -> dict:
    nparr = np.frombuffer(data, np.uint8)
    img = cv2.imdecode(nparr, cv2.IMREAD_GRAYSCALE)

    variance = cv2.Laplacian(img, cv2.CV_64F).var()

    return {
        "sharpness": round(float(variance), 2),
        "sharpness_ok": variance > 50  # Umbral típico: 50–100 según tus datos
    }

# Function to combine above functions
def validate_images(images: dict) -> dict:

    valid_images = {}
    invalid_images = {}

    for name, data in images.items():
        if not is_image_valid(data):
            invalid_images[name] = "Corrupt or unreadable"
            continue

        props = image_properties(data)
        bright = brightness_and_contrast(data)
        sharp = sharpness(data)

        if (
            props["size_ok"]
            and props["format_ok"]
            and props["color_ok"]
            and bright["brightness_ok"]
            and bright["contrast_ok"]
            and sharp["sharpness_ok"]
        ):
            valid_images[name] = data
        else:
            reasons = []
            if not props["size_ok"]:
                reasons.append("Invalid size")
            if not props["format_ok"]:
                reasons.append("Not PNG")
            if not props["color_ok"]:
                reasons.append("Not RGB/RGBA")
            if not bright["brightness_ok"]:
                reasons.append("Bad brightness")
            if not bright["contrast_ok"]:
                reasons.append("Low contrast")
            if not sharp["sharpness_ok"]:
                reasons.append("Bad sharpness")
            invalid_images[name] = ", ".join(reasons)

    return {"valid": valid_images, "invalid": invalid_images}

def duplicates(images: dict) -> dict:
    groups = {"training": {}, "validation": {}, "evaluation": {}}

    for name, data in images.items():
        lname = name.lower()
        if "-training-" in lname:
            groups["training"][name] = data
        elif "-validation-" in lname:
            groups["validation"][name] = data
        elif "-evaluation-" in lname:
            groups["evaluation"][name] = data
    results = {}

    for split, subset in groups.items():
        md5_hashes = {}
        duplicates = []
        for name, data in subset.items():
            md5 = hashlib.md5(data).hexdigest()
            if md5 in md5_hashes:
                duplicates.append((name, md5_hashes[md5]))
            else:
                md5_hashes[md5] = name
        unique_count = len(subset) - len(set([a for a, _ in duplicates]))
        results[split] = {
            "duplicates": duplicates,
            "unique_count": unique_count #how many unique images we have
        }

        print(f"\n {split.upper()}")
        print(f"Total images: {len(subset)}")
        print(f"Exact duplicates: {len(duplicates)}")

        if duplicates:
            print("Duplicate images:")
            for a, b in duplicates:
                print(f"   - {a} == {b}")
        else:
            print("No duplicates")
    return results

def count_images_by_food(images: dict):
    counts = {
        "training": defaultdict(int),
        "validation": defaultdict(int),
        "evaluation": defaultdict(int),
    }

    for name in images.keys():
        lname = name.lower()
        if "-training-" in lname:
            group = "training"
        elif "-validation-" in lname:
            group = "validation"
        elif "-evaluation-" in lname:
            group = "evaluation"
        else:
            continue

        # Before - get the name of the food
        food = os.path.basename(name).split("-")[0].capitalize()
        counts[group][food] += 1

    return counts

def process_images(client):
    all_images = {}
    for key in list_objects(client, FORMATTED_BUCKET, SRC_PREFIX):
        obj = client.get_object(FORMATTED_BUCKET, key)
        data = obj.read()
        obj.close(); obj.release_conn()
        all_images[key] = data

    # Validating images
    validated = validate_images(all_images)
    valid_images = validated["valid"]
    invalid_images = validated["invalid"]

    print("\n VALIDATION SUMMARY")
    print(f"Valid images: {len(valid_images)}")
    print(f"Invalid images: {len(invalid_images)}")

    # Duplicates
    duplicates_report = duplicates(valid_images)

    # Upload not duplicate and valid images
    uploaded_trusted = 0
    for name, data in valid_images.items():
        # Check if there are duplicate images
        if any(name == dup for group in duplicates_report.values()
               for dup, _ in group["duplicates"]):
            continue

        dst_key = dst_key_for(name,DST1_PREFIX)
        metadata = {
            "x-amz-meta-source-key": name,
            "x-amz-meta-processed-at": datetime.now(ZoneInfo("Europe/Madrid")).isoformat(),
            "x-amz-meta-format": "png",
        }
        client.put_object(
            TRUSTED_BUCKET,
            dst_key,
            io.BytesIO(data),
            length=len(data),
            content_type="image/png",
            metadata=metadata
        )
        uploaded_trusted += 1
        print(f" Uploaded to Trusted: {dst_key}")

    # Upload rejected images to the rejected-zone
    uploaded_rejected = 0
    rejected_report = {}

    if invalid_images:
        print("\n Uploading rejected images")
        for name, reason in invalid_images.items():
            data = all_images[name]
            dst_key = dst_key_for(name, DST2_PREFIX)
            metadata = {
                "x-amz-meta-source-key": name,
                "x-amz-meta-reason": reason,
                "x-amz-meta-processed-at": datetime.now(ZoneInfo("Europe/Madrid")).isoformat(),
            }
            client.put_object(
                REJECTED_BUCKET,
                dst_key,
                io.BytesIO(data),
                length=len(data),
                content_type="image/png",
                metadata=metadata
            )
            uploaded_rejected += 1

            # Keep it for the final report
            rejected_report.setdefault(reason, []).append(dst_key)


        print(f"\n Uploaded {uploaded_rejected} images to {REJECTED_BUCKET}")

        print("\nREJECTION REPORT")
        for reason, files in rejected_report.items():
            print(f"\n {reason}:")
            for f in files:
                print(f"   - {f}")

    else:
        print("\n No rejected images.")


    print(f"\nUploaded to Trusted: {uploaded_trusted}")
    print(f"Uploaded to Rejected: {uploaded_rejected}")
    food_counts = count_images_by_food(valid_images)
    print("\n IMAGE COUNT BY FOOD TYPE (Validated images)")
    for group, foods in food_counts.items():
        print(f"\n {group.upper()}")
        if not foods:
            print("   (no images found)")
        else:
            for food, count in sorted(foods.items()):
                print(f"   {food}: {count}")

def main():
      try:
          client = get_minio_client()
          process_images(client)
      except S3Error as e:
          print(f"MinIO error: {e}")
      except Exception as e:
        print(f"Unexpected error: {e}")

if __name__ == "__main__":
    main()